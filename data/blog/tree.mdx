---
title: '[ 묘공단 ] 자료구조 트리'
date: '2024-05-04'
lastmod: '2024-05-04'
tags: ['#TREE', '#자료구조', '#알고리즘', '#묘공단']
draft: false
summary: '자료구조 트리에 대해 알아보자'
images:
  [
    'https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fcdb6699c-3ce4-4a16-96b1-929cdcb3d7ef%2F9b77f5ac-e71e-41f5-8285-ee0e5bdbe0f1%2FFrame_67.png&blockId=cfd8eda1-92a5-411e-9497-8d659f3d9c91',
  ]
---

이 글은 책 `코딩테스트 합격자 되기 - 자바편 (골든래빗 - 김희성저)`의 내용이 포함되어있습니다.

![그림](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fcdb6699c-3ce4-4a16-96b1-929cdcb3d7ef%2F9b77f5ac-e71e-41f5-8285-ee0e5bdbe0f1%2FFrame_67.png&blockId=cfd8eda1-92a5-411e-9497-8d659f3d9c91)

### 트리(Tree)란?

트리는 `자료구조`의 한 종류로서 데이터를 저장하고 탐색하기 유용한 구조를 갖고 있습니다.

<span style={{ opacity: '0.7' }}>
  자료구조란 자료를 기억장치 공간 내에 저장하는 방법과 자료 간의 관계, 처리 방법 등을 연구 분석하는
  것을 말함.
</span>

트리 구조는 `노드(Node)`라고 불리는 기본 요소들로 구성되고, 각 노드는 다른 노드를 가르키는 `간선(Link) 또는 엣지(Edge)`를 통해 연결됩니다.

### 트리 관련 용어

- **노드(Node)** : 트리를 구성하는 기본요소
- **간선(Edge)** : 노드와 노드사이를 이어주는 선
- **루트 노드(Root Node)** : 트리의 최상위에 위치하는 노드, 다른 모든 노드의 조상임
- **자식 노드(Child Node)** : 다른 노드에 의해 직접 연결되어 부모-자식 관계를 이루는 노드입니다.
- **형제 노드(Sibling Node)** : 같은 부모 노드를 가지는 노드들입니다.
- **잎 노드(Leaf Node)** : 자식이 없는 노드로, 트리의 가장 아래쪽에 위치합니다.

### 트리 종류

대표적인 트리 자료구조로는 이진 트리(Binary Tree), 이진 탐색 트리(Binary Search Tree), AVL 트리, 레드-블랙 트리, B-트리 등이 있습니다.

각 트리는 특정 연산을 최적화하기 위한 구조와 규칙을 가지고 있습니다. 예를 들어, 이진 탐색 트리는 데이터를 정렬된 상태로 유지하여 검색, 삽입, 삭제 연산을 로그 시간 복잡도로 수행할 수 있게 도와줍니다.

<span style={{ opacity: '0.6', textDecoration: 'line-through' }}>
  알고리즘 문제를 해결 할 때는 이진트리만 제대로 알고 있으면 충분하다고 하기 때문에 이진트리에
  대해서 알아보자.
</span>

### 이진 트리란?

이진트리는 차수(Degree)가 2 이하인 노드들로 구성된 트리이다. 즉 자식이 둘 이하인 노드들로만 구성된 트리를 의미.

#### 이진 트리 순회 방법

![](https://i0.wp.com/hanamon.kr/wp-content/uploads/2021/07/%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%AB-%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5-%E1%84%89%E1%85%AE%E1%86%AB%E1%84%92%E1%85%AC.jpg?w=1011&ssl=1)

- **전위 순회(Preorder Traversal)** : 루트-왼쪽-오른쪽 순으로 방문합니다.
- **중위 순회(Inorder Traversal)** : 왼쪽-루트-오른쪽 순으로 방문합니다. 이 순회 방법은 이진 검색 트리에서 정렬된 순서로 노드를 방문할 때 유용합니다.
- **후위 순회(Postorder Traversal)** : 왼쪽-오른쪽-루트 순으로 방문합니다.

---

### 연습 문제

[백준 이진 검색 트리 (5639)](https://www.acmicpc.net/problem/5639)

이진 검색 트리는 다음과 같은 세 가지 조건을 만족하는 이진 트리이다.

- 노드의 왼쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 작다.
- 노드의 오른쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 크다.
- 왼쪽, 오른쪽 서브트리도 이진 검색 트리이다.

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/images/bsearchtree.png)

전위 순회 (루트-왼쪽-오른쪽)은 루트를 방문하고, 왼쪽 서브트리, 오른쪽 서브 트리를 순서대로 방문하면서 노드의 키를 출력한다. 후위 순회 (왼쪽-오른쪽-루트)는 왼쪽 서브트리, 오른쪽 서브트리, 루트 노드 순서대로 키를 출력한다. 예를 들어, 위의 이진 검색 트리의 전위 순회 결과는 `50 30 24 5 28 45 98 52 60` 이고, 후위 순회 결과는 `5 28 24 45 30 60 52 98 50` 이다.

이진 검색 트리를 전위 순회한 결과가 주어졌을 때, 이 트리를 `후위 순회한 결과`를 구하는 프로그램을 작성하시오.

#### 입력

트리를 전위 순회한 결과가 주어진다. 노드에 들어있는 키의 값은 106보다 작은 양의 정수이다. 모든 값은 한 줄에 하나씩 주어지며, 노드의 수는 10,000개 이하이다. 같은 키를 가지는 노드는 없다.

#### 출력

입력으로 주어진 이진 검색 트리를 후위 순회한 결과를 한 줄에 하나씩 출력한다.

<table style={{ width: '60%' }}>
  <thead>
    <td>예제 입력 1</td>
    <td>예제 출력 1</td>
  </thead>
  <tbody>
    <td>
      50 <br />
      30 <br />
      24 <br />
      5 <br />
      28 <br />
      45 <br />
      98 <br />
      52 <br />
      60
    </td>
    <td>
      5 <br />
      28 <br />
      24 <br />
      45 <br />
      30 <br />
      60 <br />
      52 <br />
      98 <br />
      50
    </td>
  </tbody>
</table>

```java:이진검색트리
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {
    // Node 클래스 정의: 이진 검색 트리의 각 노드를 나타냅니다.
    static class Node {
        int key;        // 노드의 키 값
        Node left, right; // 왼쪽과 오른쪽 자식 노드에 대한 참조

        // 노드 생성자: 새 노드를 초기화합니다.
        public Node(int key) {
            this.key = key;    // 키 값 설정
            this.left = null;  // 왼쪽 자식을 null로 초기화
            this.right = null; // 오른쪽 자식을 null로 초기화
        }
    }

    // 이진 검색 트리를 관리하기 위한 클래스
    static class BinarySearchTree {
        Node root; // 트리의 루트 노드

        // 키를 추가하는 메소드
        public void add(int key) {
            root = addRecursive(root, key); // 재귀적으로 키를 추가
        }

        // 재귀적으로 노드를 추가하는 메소드
        private Node addRecursive(Node current, int key) {
            if (current == null) {
                return new Node(key); // 새 노드 생성
            }

            if (key < current.key) {
                // 키가 현재 노드의 키보다 작으면 왼쪽에 추가
                current.left = addRecursive(current.left, key);
            } else if (key > current.key) {
                // 키가 현재 노드의 키보다 크면 오른쪽에 추가
                current.right = addRecursive(current.right, key);
            }

            return current; // 변경된 현재 노드 반환
        }

        // 후위 순회를 수행하고 노드 키를 출력하는 메소드
        public void printPostOrder(Node node) {
            if (node != null) {
                printPostOrder(node.left);   // 왼쪽 서브트리를 후위 순회
                printPostOrder(node.right);  // 오른쪽 서브트리를 후위 순회
                System.out.println(node.key); // 현재 노드의 키 출력
            }
        }
    }

    // 메인 메소드
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in));) {
            BinarySearchTree bst = new BinarySearchTree(); // 트리 객체 생성
            String input;

            // 한 줄씩 입력 받아 트리에 키를 추가
            while ((input = br.readLine()) != null && !input.isEmpty()) {
                int key = Integer.parseInt(input); // 입력을 정수로 변환
                bst.add(key); // 트리에 키 추가
            }

            // 후위 순회 결과를 출력
            bst.printPostOrder(bst.root);
        } catch (Exception e) {
            e.printStackTrace(); // 예외 발생 시 스택 트레이스 출력
        }
    }
}
```
